// By default, output prefixed code.
// If you are using Autoprefixer or similar, set this flag to false.
$_randomize-prefixes: true !default;

/// Determines if if a passed number is 1. a number and 2. an integer; if so, returns 'true'; if not, returns 'false'
/// @param { Number | String | Boolean | List | Map } $value - The parameter to check the type / integerity of
///
/// @group utilities
@function is-int($value){
  @if (type-of($value) == 'number') and ($value % 1 == 0) {
    @return true;
  } @else {
    @return false;
  }
}

/// Applies vendor prefixes to @keyframes
/// @param {String} $name - The name of the animation
///
/// @group utilities
///
@mixin keyframes($name) {
  @if $_randomize-prefixes {
    @-webkit-keyframes #{$name} {
      @content;
    }
  }

  @keyframes #{$name} {
    @content;
  }
}

/// Given a hue value, generates a color with random saturation and lightness, and, if the opacity parameter default of 1 is overriden, random opacity. To increase the chances of a somewhat-expected color being output, saturation is clamped between 20 and 100, and lightness between 20 and 80.
///
/// @access public
/// @group random color functions
///
/// @param {Number} $hue - A hue value between 0 and 360
/// @param {Number} $opacity (1) - The opacity of the generated color
///
/// @example scss
/// // SCSS
/// span {
///  color: random-color-by-hue(230);
/// }
///
/// @example css
/// // CSS
/// span {
///   color: #1d35af;
/// }
@function random-color-by-hue($hue, $opacity: 1) {
  @if $hue < 0 {
    @warn 'hue must be greater than 0, but `#{$hue}` given. Clamping to 0';
    $hue: 0;
  }

  @if $hue > 360 {
    $hue: $hue % 360;
  }

  @if $opacity < 0 or $opacity > 1 {
    @warn 'opacity should be a number between 0 and 1: `#{$opacity}` given. As a result, the color will be fully opaque.';
    $opacity: 1;
  }

  @return hsla($hue, random(20, 100), random(20, 80), $opacity);
}

/// Given saturation and lightness values, generates a color with random hue, and, if the opacity parameter default of 1 is overriden, random opacity.
///
/// @access public
/// @group random color functions
///
/// @param {Number} $saturation (100) - A saturation value between 0 and 100
/// @param {Number} $lightness (50) - A lightness value between 0 and 100
/// @param {Number} $opacity (1) - The opacity of the generated color
///
/// @example scss
/// // SCSS
/// span {
///  color: color-with-random-hue();
/// }
///
/// @example css
/// // CSS
/// span {
///   color: #00fff7;
/// }
@function color-with-random-hue($saturation: 100, $lightness: 50, $opacity: 1) {
  $saturation: clamp($saturation, 0, 100);
  $lightness: clamp($lightness, 0, 100);
  $opacity: clamp($opacity);

  @return hsla(random(0, 360), percentage($saturation/100), percentage($lightness/100), $opacity);
}


/// Given two colors, mix them, randomizing how much of each color to use in so doing. Optionally, pass in the lowest and highest amount of the first color that will be used in generating the mixture.
///
/// @access public
/// @group random color functions
///
/// @param {Color} $color-1 - The first color to be used in generating a mixed color
/// @param {Color} $color-2 - The second color to be used in generating a mixed color
/// @param {Number} $min-1 (10%) - The lowest amount of the first color that will be used in mixing
/// @param {Number} $max-1 (90%) - The highest amount of the first color that will be used in mixing
///
/// @example scss
/// // SCSS
/// body {
///  background: random-mix(red, blue);
/// }
///
/// @example css
/// // CSS
/// body {
///   background: #c1003d;
/// }
@function random-mix($color-1, $color-2, $min-1: 10%, $max-1: 90%){
  @return mix($color-1, $color-2, random-between($min-1, $max-1));
}

/// Given a number of elements, a property, and a function to call upon those elements, call the function separately on each property of each element; like random-animate, but without the whole 'animation' part.
///
/// @access public
/// @group mixins
///
/// @param {Number} $number-of-items - The number of elements to be iterated over
/// @param {String} $property - The property of those elements which will call the function
/// @param {String} $function - The function to be called on each element
/// @param {List} $args... - Parameters, if any, to be passed to that function
///
/// @example scss
/// // SCSS
/// span {
///   color: random-iterate(3, color, random-hex);
/// }
///
/// @example css
/// // CSS
/// span:nth-child(3) {
///   color: #488176;
/// }
/// span:nth-child(2) {
///   color: #0C0FC3;
/// }
/// span:nth-child(1) {
///   color: #DB47C4;
/// }
@mixin random-iterate($number-of-items, $property, $function, $args...) {
  $counter: 1;

  @if ($number-of-items < 1) or (type-of($number-of-items) != 'number') {
    @error '$number-of-items in random-iterate must be an integer greater than or equal to 1');
  }

  @while $number-of-items >= $counter {
    &:nth-child(#{$counter}) {
      #{$property}: call($function, $args...);
    }

    $counter: $counter + 1;
  }
}

/// Randomly animates a number of nth-children.
///
/// @access public
/// @group mixins
///
/// @param {Number} $num-elements - The number of elements to animate
/// @param {String} $prop-to-animate - The property of those elements which should be animated
/// @param {List} $animation-props - The animation properties to use for the animation
/// @param {Number} $steps - The number of times each element will be animated
/// @param {String} $function-name - The randomizing function to be called for use in the animation
/// @param {String} $args... - Parameters to be passed to the $function-name function
///
/// @example scss
/// // SCSS
/// // assuming that there are 2 spans with a class of 'demo', and that they are collectively the first (or only) children of their parent:
///  span.demo {
///    @include random-animate(3, color, 3s ease, 3, random-rgba, (1, 1, 1), .7);
///  }
///
/// @example css
/// // CSS
///  span:nth-child(2) {
///    -webkit-animation: ur8mqcnb1 3s ease;
///    animation: ur8mqcnb1 3s ease;
///  }
///  @-webkit-keyframes ur8mqcnb1 {
///    0% {
///      color: rgba(133, 150, 105, 0.7);
///    }
///    50% {
///      color: rgba(202, 105, 191, 0.7);
///    }
///    100% {
///      color: rgba(59, 238, 72, 0.7);
///    }
///  }
///  @keyframes ur8mqcnb1 {
///    0% {
///      color: rgba(25, 229, 252, 0.7);
///    }
///    50% {
///      color: rgba(128, 54, 10, 0.7);
///    }
///    100% {
///      color: rgba(49, 146, 146, 0.7);
///    }
///  }
///  span:nth-child(1) {
///    -webkit-animation: ur8mqcnba 3s ease;
///    animation: ur8mqcnba 3s ease;
///  }
///  @-webkit-keyframes ur8mqcnba {
///    0% {
///      color: rgba(61, 183, 140, 0.7);
///    }
///    50% {
///      color: rgba(169, 197, 140, 0.7);
///    }
///    100% {
///      color: rgba(241, 51, 216, 0.7);
///    }
///  }
///  @keyframes ur8mqcnba {
///    0% {
///      color: rgba(47, 37, 255, 0.7);
///    }
///    50% {
///      color: rgba(192, 105, 111, 0.7);
///    }
///    100% {
///      color: rgba(70, 183, 226, 0.7);
///    }
///  }
@mixin random-animate($num-elements, $prop-to-animate, $animation-props, $steps, $function-name, $args...) {
  @if (not is-int($steps)) or ($steps < 2) {
    @error '@mixin random-animate: $steps must be an integer with a value of at least 1.';
  }

  @if (not is-int($num-elements)) or ($num-elements < 1) {
    @error '@mixin random-animate: $num-elements must be a positive integer.';
  }

  @if not function-exists($function-name) {
    @error '@mixin random-animate: The given function name, `#{$function-name}`, does not exist';
  }

  $counter: 1;
  @while $num-elements >= $counter {
    $animation-name: unique-id();


    // Generate the proper number and % of keyframe steps
    $step-list: ();
    $steps-to-add: $steps;

    @while $steps-to-add > 0 {
      $step-list: join(floor(($steps-to-add - 1) * (100 / ($steps - 1))), $step-list);
      $steps-to-add: $steps-to-add - 1;
    }

    // Generate the results of the call before-hand to preserve
    // results across prefixes
    $steps-length: length($step-list);
    $result-list: ();

    @for $i from 1 through $steps-length {
      $result-list: append($result-list, (call($function-name, $args...)));
    }

    // Generate the keyframes using the above-generated information
    &:nth-child(#{$counter}) {
      @include keyframes($animation-name) {

        @for $i from 1 through $steps-length {
          #{nth($step-list, $i)}% {
            #{$prop-to-animate}: nth($result-list, $i);
          }
        }
      }

      // Call the keyframes
      @if $_randomize-prefixes {
        -webkit-animation: $animation-name $animation-props;
      }
      animation: $animation-name $animation-props;
    }

    $counter: $counter + 1;
  }
}